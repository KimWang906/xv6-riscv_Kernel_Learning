# OSTEP 정리

## Process

### 정의

Process는 실행 중인 프로그램입니다.

### 설명

해당 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음입니다.  
이 명령어와 데이터 묶음을 읽고 실행하여 프로그램에 생명을 불어넣는 것이 운영체제입니다.  
  
사용자는 하나 이상의 프로그램을 동시에 실행시키기를 원합니다.  
예를 들어, 웹 브라우저, 메일 프로그램, 게임, 음악 플레이어 등을 실행하는 컴퓨터를 생각해 보면  
컴퓨터들은 동시에 수십 혹은 수백 개의 프로세스를 실행하는 것처럼 보입니다.  
여러 프로그램을 동시에 실행할 수 있으면, 시스템을 쉽게 사용할 수 있고,  
사용자는 사용 가능한 CPU가 있는지 신경쓰지 않고 그저 프로그램만 실행시키면 됩니다.  
  
우리가 해결해야할 과제는 다음과 같습니다.  
  
CPU가 여러 개 존재한다는 환상을 어떻게 제공할까요?  
적은 개수의 CPU 밖에 없더라도, 운영체제는 어떻게 거의 무한개에 가까운 CPU가 있는 듯한 환상을 만들 수 있을까요?  
  
운영체제는 CPU를 가상화하여 이러한 환상을 만들어 냅니다.  
하나의 프로세스를 실행하고, 얼마 후 중단시키고 다른 프로세스를 실행하는 작업을 반복하면서 실제 하나  
또는 소수의 CPU로 여러 개의 가상 CPU가 존재하는 듯한 환상을 만들어 냅니다.  
**시분할(time sharing)** 이라 불리는 이 기법은 **원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 합니다.**  
그러나 **시분할 기법**은 CPU를 공유하기 때문에, **각 프로세스의 성능은 낮아지는 단점**이 있습니다.  

### 시분할(time sharing)

**시분할**은 자원 공유를 운영체제가 사용하는 가장 기본 기법 중 하나입니다.  
한 개체가 잠깐 자원을 사용한 후, 다른 개체가 또 잠깐 자원을 사용하고,  
그 다음 개체가 사용하면서 이 자원(CPU 또는 네트워크 링크 등)을 많은 개체들이 공유합니다.  
시분할과 자연스럽게 대응되는 개념은 **공간 분할(space sharing)**이 될 것입니다.  
  
공간 분할은 개체에게 공간을 분할해 주고, 그 예로는 공간 분할의 예로 디스크가 있습니다.  
디스크는 **자연스럽게 공간 분할할 수 있는 자원**으로,  
블럭이 하나의 파일에 할당되면 파일을 삭제하기 전에는 다른 파일이 할당될 가능성이 낮습니다.  

### 운영체제의 지능

운영체제의 지능은 **정책(policy)** 의 형태로 표현되고,  
정책은 운영체제 내에서 어떤 결정을 내리기 위한 알고리즘입니다.  
  
운영체제의 **스케줄링 정책(scheduling policy)** 이 이러한 결정을 내립니다.  
그리고 이러한 결정을 내리기 위하여 스케줄링 정책은 과거 정보(직전 1분 동안 어떤 프로그램이 자주 실행되었는지),  
워크로드에 관한 지식(어떤 유형의 프로그램들이 실행되었는지),  
및 성능 측정 결과 (시스템이 대화 성능 혹은 처리량을 높이려 하는지)를 이용합니다.  

### 개념

만약 특정 순간의 프로세스를 간단하게 표현하려면, 실행되는 동안 접근했거나 영향을 받은 자원의 목록을 작성하면 됩니다.  
프로세스의 구성 요소를 이해하기 위해서는 먼저 **하드웨어 상태(machine state)** 를 이해해야 하는데  
프로그램이 실행되는 동안 하드웨어 상태를 읽거나 갱신할 수 있습니다.  
  
이때 가장 중요한 하드웨어 구성 요소는 무엇일까요?  
  
프로세스의 하드웨어 상태 중 가장 중요한 구성 요소는 메모리이고, 이곳에는 명령어가 저장됩니다.  
또한 실행 프로그램이 읽고 쓰는 데이터 역시 메모리에 저장됩니다.  
프로세스가 접근할 수 있는 **메모리**(**주소 공간(address space)** 이라 불림)는 프로세스를 구성하는 요소입니다.  
레지스터도 프로세스의 하드웨어 상태를 구성하는 요소 중 하나이고 많은 명령어들이 레지스터를 직접 읽거나 갱신합니다.  
  
또한 프로세스를 실행할 때 레지스터도 빠질 수 없습니다.  
프로세스의 하드웨어 상태를 구성하는 레지스터 중에 특별한 레지스터들이 존재합니다.  
  
프로그램 **카운터(program counter, PC)** 는 프로그램의 어느 명령어가 실행 중인지를 알려주고  
**명령어 포인터(instruction pointer, IP)**  라고도 불립니다.  
**스택 포인터(stack pointer)** 와 **프레임 포인터(frame pointer)** 는  
함수의 변수와 리턴 주소를 저장하는 스택을 관리할 때 사용하는 레지스터입니다.  
프로그램은 영구 **저장장치 (persistent storage)** 에 접근하기도 합니다.  
이 입출력 정보는 프로세스가 현재 열어 놓은 파일 목록을 가지고 있습니다.  

* **생성 (Create)**: 운영체제는 새로운 프로세스를 생성할 수 있는 방법을 제공해야 합니다.
  * 쉘에 명령어를 입력하거나, 응용 프로그램의 아이콘을 클릭하여 프로그램을 실행시키면, 운영체제는 새로운 프로세스를 생성합니다.
  
* **제거 (Destroy)**: 프로세스 생성 인터페이스를 제공하는 것처럼 운영체제는 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야 합니다.
  * 물론, 많은 프로세스는 실행되고 할 일을 다하면 스스로 종료합니다.
  * 그러나 프로세스가 스스로 종료하지 않으면 사용자는 그 프로세스를 제거하길 원할 것이고, 필요없는 프로세스를 중단시키는 API는 매우 유용합니다.
  
* **대기 (Wait)**: 때로는 어떤 프로세스의 실행 중지를 기다릴 필요가 있기 때문에 여러 종류의 대기 인터페이스가 제공됩니다.
  
* **각종 제어 (Miscellaneous Control)**: 프로세스의 제거, 대기 이외에, 여러 가지 제어 기능들이 제공됩니다.
  * 예를 들어, 대부분의 운영체제는 프로세스를 일시정지하거나 재개 (일시정지되었던 프로세스의 실행을 다시 시작)하는 기능을 제공합니다.
  
* **상태 (Status)**: 프로세스 상태 정보를 얻어내는 인터페이스도 제공됩니다.
  * 상태 정보에는 얼마 동안 실행되었는지 또는 프로세스가 어떤 상태에 있는지 등이 포함됩니다.

### 프로세스 상태

상태의 개념은 초기 컴퓨터 시스템에서 등장하였습니다.  

프로세스 상태를 단순화하면 다음 세 상태 중 하나에 존재할 수 있습니다.  

<p align="center"><img src="/readme_img/process_state.png"></p>

* **실행 (Running)**: 실행 상태에서 프로세스는 프로세서에서 실행 중입니다.
  * 즉, 프로세스는 명령어를 실행하고 있습니다.
  
* **준비 (Ready)**: 준비 상태에서 프로세스는 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중입니다.
  
* **대기 (Blocked)**: 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산입니다.
  * 흔한 예 : 프로세스가 디스크에 대한 입출력 요청을 하였을 때
  * 프로세스는 입출력이 완료될 때까지 대기 상태가 되고, 다른 프로세스가 실행상태로 될 수 있습니다.

### 자료구조

운영체제도 일종의 프로그램이고, 다른 프로그램들과 같이 다양한 정보를 유지하기 위한 자료 구조를 가지고 있습니다.  
예를 들어, 프로세스 상태를 파악하기 위해 준비 상태의 프로세스들을 위한 프로세스 **리스트(process list)** 와 같은 자료 구조를 유지합니다.  
또한, 어느 프로세스가 실행 중인지를 파악하기 위한 부가적인 자료 구조도 유지합니다.  
운영체제는 또 대기 상태인 프로세스도 파악해야 합니다.  
입출력 요청이 완료되면 운영체제는 적절한 프로세스를 깨워 준비 상태로 다시 전이시킬 수 있어야 합니다.

```//
// 프로세스를 중단하고 이후에 재개하기 위해
// xv6가 저장하고 복원하는 레지스터
struct context {
  uint64 ra;
  uint64 sp;

  // callee-saved
  uint64 s0;
  uint64 s1;
  uint64 s2;
  uint64 s3;
  uint64 s4;
  uint64 s5;
  uint64 s6;
  uint64 s7;
  uint64 s8;
  uint64 s9;
  uint64 s10;
  uint64 s11;
};

// 가능한 프로세스 상태
/*
    아래 코드에서 실행, 준비, 대기 외에 다른 상태들이 존재하는 것을 볼 수 있는데, 
    초기(initial) 상태(프로세스가 생성되는 동안에는 초기 상태에 머무는 것)를 가지는 시스템도 있습니다.  
    프로세스는 종료되었지만 메모리에 남아있는 상태인 최종(inal)상태도 있습니다.
    (Unix-기반 시스템에서 이 상태는 좀비(zombie) 상태라고 불립니다)  
    이 상태는 프로세스가 성공적으로 실행했는지를 다른 프로세스(보통은 부모(parent)프로세스)가 검사하는 데 유용합니다.  
    이를 위하여 최종 상태를 활용합니다. (Unix-기반 시스템에서는 프로세스가 성공적으로 종료되었으면 0을, 그렇지 않으면 0이 아닌 값을 반환합니다)  
    부모 프로세스는 자식 프로세스의 종료를 대기하는 시스템 콜을 호출(예, wait())하고, 
    해당 호출은 종료된 프로세스와 관련된 자원들을 정리할 수 있다고 운영체제에 알리는 역할도 합니다.
*/
enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };

struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state(프로세스의 상태)
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                    // Process ID
  int pgid;                   // Process Group ID(8 / 1 Update)
  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process(부모 프로세스)

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack(이 프로세스의 커널 스택의 바닥주소)
  uint64 sz;                   // Size of process memory (bytes)(프로세스 메모리의 크기)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory(현재 디렉터리)
  char name[16];               // Process name (debugging)
};
```

위 코드는 xv6 커널에서 각 프로세스를 추적하기 위해 운영체제가 필요로 하는 정보를 보이고 있습니다.  
Linux, Mac OS X, 또는 Windows 같은 운영체제들도 이와 비슷한 프로세스 구조를 가지고 있고, 찾아 보면 훨씬 복잡하다는 것을 알 수 있습니다.
  
우리는 위 코드를 통해 운영체제가 관리하는 있는 프로세스 정보를 알 수 있습니다.
  
**레지스터 문맥(register context)** 자료 구조는 프로세스가 중단되었을 때 해당 프로세스의 레지스터값들을 저장합니다.  
이 레지스터값들을 복원하여 (예, 해당 값을 실제 물리 레지스터에 다시 저장함으로써) 운영체제는 프로세스 실행을 재개합니다.  
**문맥 교환(context switch)** 이라고 알려진 이 기법에 관해서 추후 자세히 다루기로 합니다.

### [출처](https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/04-cpu-intro.pdf)
